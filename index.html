<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Demon Core: Chicken Race</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #1a1a1a;
            color: #e0e0e0; font-family: 'Courier New', monospace;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; height: 100vh;
            user-select: none; touch-action: none;
        }
        /* èµ°æŸ»ç·šã‚¨ãƒ•ã‚§ã‚¯ãƒˆ */
        body::after {
            content: " "; display: block; position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 10;
        }
        canvas {
            background: radial-gradient(circle, #2a3a2a, #000);
            border: 2px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.8);
            cursor: ns-resize;
        }
        #ui { position: absolute; top: 20px; text-align: center; width: 100%; z-index: 20; pointer-events: none; }
        h1 { margin: 0; font-size: 20px; color: #888; letter-spacing: 2px; }
        
        /* ã‚¹ã‚³ã‚¢ï¼ˆè·é›¢ï¼‰è¡¨ç¤º */
        #score-container { margin-top: 10px; }
        .label { font-size: 14px; color: #aaa; }
        #current-gap { font-size: 24px; font-weight: bold; color: #fff; }
        #record-display { font-size: 40px; font-weight: bold; color: #0f0; text-shadow: 0 0 10px #0f0; }
        .unit { font-size: 16px; color: #888; }

        #message { margin-top: 20px; color: #ff3333; display: none; font-weight: bold; font-size: 24px; text-shadow: 0 0 5px #f00; }
        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s; mix-blend-mode: screen; z-index: 15;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>PROJECT: TICKLING THE TAIL</h1>
        <div id="score-container">
            <div><span class="label">CURRENT GAP:</span> <span id="current-gap">--</span> <span class="unit">mm</span></div>
            <div><span class="label">MIN RECORD:</span> <span id="record-display">--</span> <span class="unit">mm</span></div>
        </div>
        <div id="message">CRITICALITY ACCIDENT<br><span style="font-size:16px; color:#fff;">CLICK TO RESET</span></div>
    </div>
    
    <div id="flash-overlay"></div>
    <canvas id="gameCanvas" width="600" height="400"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const currentGapEl = document.getElementById('current-gap');
    const recordEl = document.getElementById('record-display');
    const msgEl = document.getElementById('message');
    const flashEl = document.getElementById('flash-overlay');
    const supabaseUrl = 'https://ajssmfnjxulsoecxwkss.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFqc3NtZm5qeHVsc29lY3h3a3NzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1NjY3NzEsImV4cCI6MjA4NjE0Mjc3MX0.LgX0_BbxP8hysXXq76vb7FQdl8dJBiAu-pXy4c6WdR0'; // Project Settings > API ã§ç¢ºèªã§ãã¾ã™
    const _supabase = supabase.createClient(supabaseUrl, supabaseKey);

// â–¼ ãƒ©ãƒ³ã‚­ãƒ³ã‚°é€ä¿¡é–¢æ•°
    async function sendScore(score) {
    const name = prompt("GAME OVER! Enter your name for the ranking:", "Guest");
    if (!name) return;

    const { error } = await _supabase
        .from('scores')
        .insert({ username: name, score: score });

    if (error) {
        alert("Error saving score: " + error.message);
    } else {
        alert("Score sent to the leaderboard!");
        showRanking(); // é€ä¿¡å¾Œã«ãƒ©ãƒ³ã‚­ãƒ³ã‚°ã‚’è¡¨ç¤º
    }
}

// â–¼ ãƒ©ãƒ³ã‚­ãƒ³ã‚°å–å¾—ãƒ»è¡¨ç¤ºé–¢æ•°
    async function showRanking() {
    // ã‚¹ã‚³ã‚¢ã®é«˜ã„é †ã«ãƒˆãƒƒãƒ—5ã‚’å–å¾—
    const { data, error } = await _supabase
        .from('scores')
        .select('*')
        .order('score', { ascending: false }) // é™é †ï¼ˆé«˜ã„æ–¹ãŒä¸Šï¼‰
        .limit(5);

    if (error) {
        console.error(error);
        return;
    }

    // ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã«è¡¨ç¤ºï¼ˆç°¡æ˜“ç‰ˆï¼‰
    // æœ¬æ¥ã¯HTMLä¸Šã«æç”»ã™ã‚‹ã»ã†ãŒç¶ºéº—ã§ã™ãŒã€ã¾ãšã¯å‹•ãã‹ç¢ºèª
    let msg = "ğŸ† TOP 5 SCORES ğŸ†\n";
    data.forEach((row, i) => {
        msg += `${i+1}. ${row.username}: ${row.score}\n`;
    });
    alert(msg);
}
    // ã‚²ãƒ¼ãƒ ã®çŠ¶æ…‹
    let gameState = {
        gap: 50.00,        // ç¾åœ¨ã®è·é›¢ (1px = 1mm ã¨ã™ã‚‹)
        minRecord: 50.00,  // ä»Šå›ã®ãƒ—ãƒ¬ã‚¤ã§ã®æœ€å°æ¥è¿‘è¨˜éŒ²
        isGameOver: false,
        shaking: 0
    };

    let targetGap = 50;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2 + 50;
    const coreRadius = 60;
    const shellRadius = 70;

    // éŸ³éŸ¿è¨­å®š
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;

    function initAudio() {
        if (!audioCtx) audioCtx = new AudioContext();
        if (audioCtx.state === 'suspended') audioCtx.resume();
    }

    function playGeigerClick() {
        if (!audioCtx) return;
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.value = 100 + Math.random() * 50;
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.03);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.03);
    }

    // ãƒã‚¦ã‚¹/ã‚¿ãƒƒãƒæ“ä½œ
    function handleInput(clientY) {
        initAudio(); // åˆå›æ“ä½œã§ã‚ªãƒ¼ãƒ‡ã‚£ã‚ªæœ‰åŠ¹åŒ–
        if (gameState.isGameOver) return;
        
        // ç”»é¢æ¯”ç‡ã‹ã‚‰ç›®æ¨™ä½ç½®ã‚’è¨ˆç®—
        const percent = Math.max(0, Math.min(1, clientY / window.innerHeight));
        // ä¸‹ã«è¡Œãã»ã©è¿‘ã¥ãï¼ˆ0mmã€œ100mmã®ç¯„å›²ï¼‰
        targetGap = percent * 120; 
    }

    document.addEventListener('mousemove', (e) => handleInput(e.clientY));
    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
        handleInput(e.touches[0].clientY);
    }, { passive: false });

    document.addEventListener('click', () => {
        if (gameState.isGameOver) resetGame();
        else initAudio();
    });

    function resetGame() {
        gameState.gap = 50;
        gameState.minRecord = 50;
        gameState.isGameOver = false;
        gameState.shaking = 0;
        msgEl.style.display = 'none';
        flashEl.style.opacity = 0;
        recordEl.style.color = '#0f0';
        loop();
    }

    function update() {
        if (gameState.isGameOver) return;

        // æ‰‹ã®éœ‡ãˆè¨ˆç®—ï¼ˆè¿‘ã¥ãã»ã©éœ‡ãˆã‚‹ï¼‰
        // 20mmä»¥ä¸‹ã‹ã‚‰éœ‡ãˆå§‹ã‚ã€0mmã«è¿‘ã„ã¨æ¿€ã—ãéœ‡ãˆã‚‹
        let instability = 0;
        if (gameState.gap < 20) {
            instability = (20 - gameState.gap) * 0.15; // éœ‡ãˆä¿‚æ•°
        }
        
        const tremor = (Math.random() - 0.5) * instability;
        
        // ç‰©ç†æŒ™å‹•ï¼šã‚¿ãƒ¼ã‚²ãƒƒãƒˆã«å‘ã‹ã£ã¦æ»‘ã‚‰ã‹ã«å‹•ã + éœ‡ãˆ
        gameState.gap += (targetGap - gameState.gap) * 0.08 + tremor;

        // æ¥è§¦åˆ¤å®š
        if (gameState.gap <= 0.0) {
            gameState.gap = 0;
            triggerGameOver();
        }

        // --- ä»Šå›ã®å¤‰æ›´ç‚¹ï¼šæœ€å°è·é›¢ã®æ›´æ–°ãƒ­ã‚¸ãƒƒã‚¯ ---
        // ã¾ã æ¥è§¦ã—ã¦ã„ãªã‘ã‚Œã°è¨˜éŒ²æ›´æ–°
        if (gameState.gap > 0 && gameState.gap < gameState.minRecord) {
            gameState.minRecord = gameState.gap;
        }

        // è¡¨ç¤ºæ›´æ–°ï¼ˆå°æ•°ç‚¹2æ¡ã¾ã§ï¼‰
        currentGapEl.innerText = gameState.gap.toFixed(2);
        recordEl.innerText = gameState.minRecord.toFixed(2);

        // UIè‰²å¤‰åŒ–ï¼ˆå±é™ºåº¦æ¼”å‡ºï¼‰
        if (gameState.minRecord < 5.00) recordEl.style.color = '#f0f'; // è¶…å±é™º
        else if (gameState.minRecord < 15.00) recordEl.style.color = '#ff0'; // æ³¨æ„
        else recordEl.style.color = '#0f0'; // å®‰å…¨

        // ç”»é¢ã®æºã‚Œï¼ˆæç”»ç”¨ï¼‰
        gameState.shaking = instability * 2;

        // ã‚¬ã‚¤ã‚¬ãƒ¼ã‚«ã‚¦ãƒ³ã‚¿ãƒ¼éŸ³
        // è·é›¢ãŒè¿‘ã„ã»ã©ç¢ºç‡ã‚¢ãƒƒãƒ—
        if (Math.random() < Math.pow((60 - gameState.gap)/60, 4)) {
            playGeigerClick();
        }
    }

    function draw() {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // æŒ¯å‹•é©ç”¨
        const shakeX = (Math.random() - 0.5) * gameState.shaking;
        const shakeY = (Math.random() - 0.5) * gameState.shaking;
        ctx.save();
        ctx.translate(shakeX, shakeY);

        // 1. ãƒ‰ãƒ©ã‚¤ãƒãƒ¼
        ctx.strokeStyle = '#aaa';
        ctx.lineWidth = 8;
        ctx.beginPath();
        // éš™é–“ã«åˆã‚ã›ã¦ãƒ‰ãƒ©ã‚¤ãƒãƒ¼ã®ä½ç½®ã‚‚å¾®èª¿æ•´
        let driverY = centerY - (gameState.gap / 2); 
        ctx.moveTo(centerX - 160, centerY + 10); 
        ctx.lineTo(centerX - coreRadius + 5, driverY); 
        ctx.stroke();
        
        // æŒã¡æ‰‹
        ctx.fillStyle = '#c44';
        ctx.fillRect(centerX - 200, centerY, 40, 15);

        // 2. ã‚³ã‚¢ï¼ˆä¸‹ï¼‰
        ctx.fillStyle = '#444';
        ctx.fillRect(centerX - 50, centerY + coreRadius - 5, 100, 20); // å°åº§
        
        ctx.beginPath();
        ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
        // å±é™ºåº¦ã§ã‚³ã‚¢ãŒé’ãå…‰ã‚‹
        const dangerLevel = Math.max(0, 20 - gameState.gap) / 20; 
        ctx.fillStyle = `rgb(${100 - dangerLevel*100}, ${100 - dangerLevel*50}, ${100 + dangerLevel*155})`;
        ctx.fill();
        ctx.strokeStyle = '#111';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 3. åå°„ä½“ï¼ˆä¸Šï¼‰
        const shellY = centerY - gameState.gap;
        ctx.beginPath();
        ctx.arc(centerX, shellY, shellRadius, Math.PI, 0); 
        ctx.fillStyle = '#bbb';
        ctx.fill();
        ctx.lineWidth = 4;
        ctx.strokeStyle = '#888';
        ctx.stroke();
        // æ–­é¢
        ctx.beginPath();
        ctx.moveTo(centerX - shellRadius, shellY);
        ctx.lineTo(centerX + shellRadius, shellY);
        ctx.strokeStyle = '#666';
        ctx.lineWidth = 2;
        ctx.stroke();

        // 4. é’ã„å…‰ï¼ˆç©ºæ°—é›»é›¢ï¼‰
        if (gameState.gap < 15) {
            const alpha = (15 - gameState.gap) / 15;
            ctx.shadowBlur = 30 + Math.random() * 20;
            ctx.shadowColor = `rgba(100, 200, 255, ${alpha})`;
            ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.3})`;
            ctx.globalCompositeOperation = 'lighter';
            ctx.beginPath();
            ctx.arc(centerX, centerY, coreRadius + 10, 0, Math.PI * 2);
            ctx.fill();
            ctx.globalCompositeOperation = 'source-over';
            ctx.shadowBlur = 0;
        }

        // ãƒã‚¤ã‚ºæ¼”å‡ºï¼ˆå±é™ºæ™‚ï¼‰
        if (gameState.gap < 10) {
           renderNoise((10 - gameState.gap) * 3);
        }

        ctx.restore();
    }

    function renderNoise(amount) {
        const w = canvas.width;
        const h = canvas.height;
        const idata = ctx.getImageData(0, 0, w, h);
        const data = idata.data;
        for (let i = 0; i < data.length; i += 4) {
            if (Math.random() * 100 < amount) {
                const val = Math.random() * 255;
                data[i] = val; data[i+1] = val; data[i+2] = 255;
            }
        }
        ctx.putImageData(idata, 0, 0);
    }

    function triggerGameOver() {
    gameState.isGameOver = true;
    flashEl.style.opacity = 1;
    msgEl.style.display = 'block';
    scoreEl.innerText = "FATAL ERROR";
    scoreEl.style.color = "red";

    // â–¼ è¿½åŠ ï¼šå°‘ã—å¾…ã£ã¦ã‹ã‚‰ã‚¹ã‚³ã‚¢é€ä¿¡å‡¦ç†
    setTimeout(() => {
        sendScore(Math.floor(gameState.score));
    }, 1000);
}

    function loop() {
        if (!gameState.isGameOver) {
            update();
            draw();
            requestAnimationFrame(loop);
        } else {
            draw(); // ã‚²ãƒ¼ãƒ ã‚ªãƒ¼ãƒãƒ¼æ™‚ã‚‚æç”»ã ã‘æ›´æ–°ï¼ˆä½™éŸ»ï¼‰
        }
    }

    loop();
</script>
</body>
</html>