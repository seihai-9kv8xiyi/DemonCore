<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Demon Core: Precision</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        body {
            margin: 0; overflow: hidden; background-color: #1a1a1a;
            color: #e0e0e0; font-family: 'Courier New', monospace;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center; height: 100vh;
            user-select: none; touch-action: none;
        }
        body::after {
            content: " "; display: block; position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            background-size: 100% 2px, 3px 100%; pointer-events: none; z-index: 10;
        }
        canvas {
            background: radial-gradient(circle, #2a3a2a, #000);
            border: 2px solid #555; box-shadow: 0 0 20px rgba(0,0,0,0.8);
            cursor: ns-resize;
        }
        #ui { position: absolute; top: 10px; text-align: center; width: 100%; z-index: 20; pointer-events: none; }
        h1 { margin: 0; font-size: 18px; color: #888; letter-spacing: 2px; }
        
        #score-container { margin-top: 5px; }
        .label { font-size: 14px; color: #aaa; }
        /* 文字サイズ調整 */
        #current-gap { font-size: 28px; font-weight: bold; color: #fff; letter-spacing: 1px; }
        #record-display { font-size: 36px; font-weight: bold; color: #0f0; text-shadow: 0 0 10px #0f0; letter-spacing: 1px; }
        .unit { font-size: 16px; color: #888; }

        #ranking-board {
            position: absolute; bottom: 10px; right: 10px;
            background: rgba(0, 0, 0, 0.8); border: 1px solid #444;
            padding: 10px; font-size: 12px; color: #ccc;
            pointer-events: none; z-index: 15; text-align: left;
            display: none;
        }
        #ranking-title { color: #f0f; font-weight: bold; border-bottom: 1px solid #f0f; margin-bottom: 5px; }

        #message { margin-top: 10px; color: #ff3333; display: none; font-weight: bold; font-size: 24px; text-shadow: 0 0 10px #f00; background: rgba(0,0,0,0.7); padding: 10px; }
        
        #input-area {
            pointer-events: auto; display: none; margin-top: 10px;
        }
        input { background: #333; border: 1px solid #666; color: white; padding: 5px; font-family: monospace; }
        button { background: #d33; color: white; border: none; padding: 5px 10px; font-family: monospace; cursor: pointer; }

        #flash-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: white; opacity: 0; pointer-events: none; transition: opacity 0.1s; mix-blend-mode: screen; z-index: 15;
        }
    </style>
</head>
<body>

    <div id="ui">
        <h1>PROJECT: TICKLING THE TAIL</h1>
        <div id="score-container">
            <div><span class="label">CURRENT:</span> <span id="current-gap">--</span> <span class="unit">mm</span></div>
            <div><span class="label">CLOSEST:</span> <span id="record-display">--</span> <span class="unit">mm</span></div>
        </div>
        <div id="message">CRITICALITY ACCIDENT<br><span style="font-size:16px; color:#fff">CONTACT DETECTED</span></div>
        
        <div id="input-area">
            <input type="text" id="username" placeholder="NAME" maxlength="10">
            <button onclick="submitScore()">SEND RECORD</button>
            <div style="font-size: 10px; margin-top: 5px; color:#888;">Record before crash will be sent</div>
        </div>
    </div>

    <div id="ranking-board">
        <div id="ranking-title">TOP 5 RECORDS (closest)</div>
        <div id="ranking-list">Loading...</div>
    </div>
    
    <div id="flash-overlay"></div>
    <canvas id="gameCanvas" width="600" height="400"></canvas>

<script>
    // ▼▼▼ Supabase設定 ▼▼▼
    const supabaseUrl = 'https://ajssmfnjxulsoecxwkss.supabase.co';
    const supabaseKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImFqc3NtZm5qeHVsc29lY3h3a3NzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1NjY3NzEsImV4cCI6MjA4NjE0Mjc3MX0.LgX0_BbxP8hysXXq76vb7FQdl8dJBiAu-pXy4c6WdR0';
    // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲

    const _supabase = supabase.createClient(supabaseUrl, supabaseKey);
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const currentGapEl = document.getElementById('current-gap');
    const recordEl = document.getElementById('record-display');
    const msgEl = document.getElementById('message');
    const inputArea = document.getElementById('input-area');
    const rankingBoard = document.getElementById('ranking-board');
    const rankingList = document.getElementById('ranking-list');
    const flashEl = document.getElementById('flash-overlay');

    let gameState = {
        gap: 50.000,
        minRecord: 50.000,
        isGameOver: false,
        shaking: 0,
        gameActive: true
    };

    let targetGap = 50;
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2 + 50;
    const coreRadius = 60;
    const shellRadius = 70;

    // 音響
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    let audioCtx;
    function playGeigerClick() {
        if (!audioCtx) { audioCtx = new AudioContext(); }
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = 'square';
        osc.frequency.value = 100 + Math.random() * 50;
        gain.gain.setValueAtTime(0.05, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.03);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + 0.03);
    }

    // 操作
    function handleInput(clientY) {
        if (!gameState.gameActive) return;
        const percent = Math.max(0, Math.min(1, clientY / window.innerHeight));
        targetGap = percent * 120;
    }
    document.addEventListener('mousemove', (e) => handleInput(e.clientY));
    document.addEventListener('touchmove', (e) => { e.preventDefault(); handleInput(e.touches[0].clientY); }, { passive: false });

    function update() {
        if (!gameState.gameActive) return;

        let instability = 0;
        if (gameState.gap < 20) instability = (20 - gameState.gap) * 0.15;
        const tremor = (Math.random() - 0.5) * instability;
        
        // 物理更新
        gameState.gap += (targetGap - gameState.gap) * 0.08 + tremor;

        // 【変更点】0.000以下になったら即死（0以下にはしない）
        if (gameState.gap <= 0.001) { 
            // 0.001未満になったら、表示上は0.000になり接触扱い
            gameState.gap = 0;
            triggerGameOver();
            return; // ここで更新を止める
        }

        // 【変更点】生きていれば記録更新（接触してない時のみ更新）
        if (gameState.gap < gameState.minRecord) {
            gameState.minRecord = gameState.gap;
        }

        // 表示（小数点3桁）
        currentGapEl.innerText = gameState.gap.toFixed(3);
        recordEl.innerText = gameState.minRecord.toFixed(3);

        // 色変化
        if (gameState.minRecord < 1.000) recordEl.style.color = '#f0f'; // 1mm以下は紫
        else if (gameState.minRecord < 5.000) recordEl.style.color = '#ff0';
        else recordEl.style.color = '#0f0';

        gameState.shaking = instability * 2;
        if (Math.random() < Math.pow((60 - gameState.gap)/60, 4)) playGeigerClick();
    }

    function draw() {
        ctx.fillStyle = '#222';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        const shakeX = (Math.random() - 0.5) * gameState.shaking;
        const shakeY = (Math.random() - 0.5) * gameState.shaking;
        ctx.save();
        ctx.translate(shakeX, shakeY);

        ctx.strokeStyle = '#aaa'; ctx.lineWidth = 8; ctx.beginPath();
        let driverY = centerY - (gameState.gap / 2); 
        ctx.moveTo(centerX - 160, centerY + 10); ctx.lineTo(centerX - coreRadius + 5, driverY); ctx.stroke();
        ctx.fillStyle = '#c44'; ctx.fillRect(centerX - 200, centerY, 40, 15);

        ctx.fillStyle = '#444'; ctx.fillRect(centerX - 50, centerY + coreRadius - 5, 100, 20);
        ctx.beginPath(); ctx.arc(centerX, centerY, coreRadius, 0, Math.PI * 2);
        const dangerLevel = Math.max(0, 20 - gameState.gap) / 20; 
        ctx.fillStyle = `rgb(${100 - dangerLevel*100}, ${100 - dangerLevel*50}, ${100 + dangerLevel*155})`;
        ctx.fill(); ctx.strokeStyle = '#111'; ctx.lineWidth = 2; ctx.stroke();

        const shellY = centerY - gameState.gap;
        ctx.beginPath(); ctx.arc(centerX, shellY, shellRadius, Math.PI, 0); 
        ctx.fillStyle = '#bbb'; ctx.fill(); ctx.lineWidth = 4; ctx.strokeStyle = '#888'; ctx.stroke();
        ctx.beginPath(); ctx.moveTo(centerX - shellRadius, shellY); ctx.lineTo(centerX + shellRadius, shellY);
        ctx.strokeStyle = '#666'; ctx.lineWidth = 2; ctx.stroke();

        if (gameState.gap < 15) {
            const alpha = (15 - gameState.gap) / 15;
            ctx.shadowBlur = 30; ctx.shadowColor = `rgba(100, 200, 255, ${alpha})`;
            ctx.fillStyle = `rgba(100, 200, 255, ${alpha * 0.3})`;
            ctx.globalCompositeOperation = 'lighter';
            ctx.beginPath(); ctx.arc(centerX, centerY, coreRadius + 10, 0, Math.PI * 2); ctx.fill();
            ctx.globalCompositeOperation = 'source-over'; ctx.shadowBlur = 0;
        }
        ctx.restore();
    }

    function triggerGameOver() {
        gameState.gameActive = false;
        gameState.isGameOver = true;
        flashEl.style.opacity = 1; // 閃光
        
        currentGapEl.innerText = "0.000"; // 強制的に0表示
        
        msgEl.style.display = 'block';
        // 接触時のメッセージ。記録は「直前の最小値」を表示
        msgEl.innerHTML = `EXPERIMENT FAILED<br><span style="font-size:16px; color:white">CLOSEST SAFE DISTANCE: ${gameState.minRecord.toFixed(3)} mm</span>`;
        
        inputArea.style.display = 'block';
        fetchRanking();
        rankingBoard.style.display = 'block';

        setTimeout(() => { flashEl.style.opacity = 0; }, 3000);
    }

    async function submitScore() {
        const username = document.getElementById('username').value || "Unknown";
        // 0.000 (接触) は送信させない、または直前のレコードを送る
        // ここでは minRecord (接触直前の値) を送る
        const record = gameState.minRecord;

        // もし何もしないで即死した場合など、レコードが大きすぎる場合は弾く
        if(record > 49) {
            alert("Too far to record!");
            return;
        }

        document.querySelector('button').disabled = true;
        document.querySelector('button').innerText = "SENDING...";

        const { error } = await _supabase
            .from('scores')
            .insert({ username: username, distance: record });

        if (error) {
            alert("Error: " + error.message);
            document.querySelector('button').disabled = false;
        } else {
            alert("Record Uploaded!");
            location.reload(); 
        }
    }

    async function fetchRanking() {
        const { data, error } = await _supabase
            .from('scores')
            .select('*')
            .order('distance', { ascending: true })
            .limit(5);

        if (data) {
            let html = "";
            data.forEach((row, index) => {
                // 色分け演出
                let color = "#0f0";
                if(row.distance < 0.500) color = "#f0f"; // 超接近
                else if(row.distance < 2.000) color = "#ff0";

                html += `<div>${index + 1}. ${row.username}: <span style="color:${color}">${row.distance.toFixed(3)} mm</span></div>`;
            });
            rankingList.innerHTML = html;
        }
    }

    function loop() {
        update();
        draw();
        if (!gameState.isGameOver) {
            requestAnimationFrame(loop);
        } else {
            draw();
        }
    }

    loop();
</script>
</body>
</html>
